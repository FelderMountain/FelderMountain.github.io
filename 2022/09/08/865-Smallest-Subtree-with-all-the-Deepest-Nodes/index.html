<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Insist on doing small things."><title>865. Smallest Subtree with all the Deepest Nodes | Pinkman Tech Space</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">865. Smallest Subtree with all the Deepest Nodes</h1><a id="logo" href="/.">Pinkman Tech Space</a><p class="description">Insist on doing small things, then witness the magic</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">865. Smallest Subtree with all the Deepest Nodes</h1><div class="post-meta">2022-09-08<span> | </span><span class="category"><a href="/categories/LeetCode-Notes/">LeetCode Notes</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.4k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> deepest;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> found;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> findSubTree(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; deepest) &#123;</span><br><span class="line">            deepest = depth;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (depth == deepest) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        helper(node.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">findSubTree</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">foundNodes</span> <span class="operator">=</span> found;</span><br><span class="line">        <span class="keyword">if</span> (depth == deepest) &#123;</span><br><span class="line">            found += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (found - foundNodes == count) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftTree</span> <span class="operator">=</span> findSubTree(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (leftTree != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found - foundNodes == count) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> findSubTree(node.right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (rightTree != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found - foundNodes == count) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我自己写的第一版. 首先是看deepest nodes的count是多少. 然后看哪个树包含了所有的. 由于是递归, 因此从下到上第一个遇到的包含所有的deepest nodes的node就是答案. 递归函数等于是在dfs, 然后到一个node的时候看找到了多少个deepest nodes, 回来的时候又找到了多少个. 只有是刚来的时候一个没找到, 回来的时候发现全找到了. 这就是LCA的特征.</p>
<p>其实仔细想一想, 所有deepest nodes的LCA, 如果只有一个deepest node, 那么它自己就是LCA; 如果有多个, 那么任何一个deepest node都不可能是LCA. 有了这个判断, 其实我们之前写的答案里面有些就是冗余的. 比如33行的判断, 这一行只有在一个地方会激活那就是如果只有一个deepest node的时候. 其实我们可以先找左支, 再找右支, 最后再看自己是不是deepest. 最后再判断自己代表的树是否包含了所有的deepest. 这样的话即使是只有一个deepest的情况, 先看左再看右会遇到null直接返回回来, 也不怎么耗费东西. 而且需要注意的是我们在遍历完左树后, 只需要判断左树是否找到了LCA, 不需要判断此时自己是不是就是LCA. 因为如果一个node是LCA, 那它左右两支树一定都包含有deepest nodes(除了只有一个deepest node的情况). 为什么? 我们想像所有的deepest nodes都往上走, 最终会交汇到一个点, 这个点就是LCA. 假设这个点没有一边的支, 那么等于说是所有的deepest nodes 全都是从一条路来到了这个node. 那这样的话, 该node唯一的child岂不是比该node更靠下, 而且也包含了所有的deeepst nodes? 因此我们的假设不成立.</p>
<p>当我们把左右两树都找完后, 再判断自己是否是deepest, 然后只有这样, 再判断自己是否为LCA.<br>因此可以写成下面这个样子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> deepest;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> found;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> findSubTree(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; deepest) &#123;</span><br><span class="line">            deepest = depth;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (depth == deepest) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        helper(node.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">findSubTree</span><span class="params">(TreeNode node, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">foundNodes</span> <span class="operator">=</span> found;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftTree</span> <span class="operator">=</span> findSubTree(node.left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (leftTree != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightTree</span> <span class="operator">=</span> findSubTree(node.right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (rightTree != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth == deepest) &#123;</span><br><span class="line">            found += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> found - foundNodes == count ? node : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来就漂亮多了.</p>
<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root).getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pair&lt;Integer, TreeNode&gt; <span class="title function_">helper</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Pair&lt;Integer, TreeNode&gt; left = helper(node.left);</span><br><span class="line">        Pair&lt;Integer, TreeNode&gt; right = helper(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> left.getKey();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> right.getKey();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(Math.max(leftDepth, rightDepth) + <span class="number">1</span>,</span><br><span class="line">                leftDepth == rightDepth ? node : leftDepth &gt; rightDepth ? left.getValue() : right.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lee哥的神解法. 之前讨论的是如果是所有deepest nodes的LCA, 那么它们的左右肯定都有deepest nodes. 换句话说, 它们的左右树的height肯定是一样的. 当然也有可能不是LCA的node同样满足这个条件, 那如何区分它们的? 那就是看最大的height. 我们先看自己的左右支的height是否相同, 如果相同, 我们就返回自己, 如果不相同, 那就返回最大的那个, 因为这个很有可能就是答案.</p>
<p>按照上面的逻辑, 我们最终得到的就是那个左右支height相同的node并且它所包含的node是最深的.</p>
<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">deepest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subtreeWithAllDeepest</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            deepest = Math.max(deepest, level);</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDeepest</span> <span class="operator">=</span> dfs(node.left, level + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDeepest</span> <span class="operator">=</span> dfs(node.right, level + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">currDeepest</span> <span class="operator">=</span> Math.max(leftDeepest, rightDeepest);</span><br><span class="line">        <span class="keyword">if</span> (leftDeepest == deepest &amp;&amp; rightDeepest == deepest) &#123;</span><br><span class="line">            ans = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currDeepest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个最好理解. 递归函数的功能就是我们传进去一个tree, 它告诉我们这个tree包含的nodes中, 最深的node的depth是多少. 根据我们之前的证明, 所有deepest nodes的左树和右树都应该包含deepest nodes(当然如果只有一个deepest nodes除外). 因此我们可以把null假设也为nodes, 这样的话, 即使只有一个deepest non-null node, 它也满足左右树都包含deepest nodes, 尽管这两个nodes都是null. 于是我们用一个global variable记录deepest是多少. 我们知道deepest只能在null处达到. 因此在遇到null的时候更新deepest即可.</p>
<p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2022/09/08/1559-Detect-Cycles-in-2D-Grid/">1559. Detect Cycles in 2D Grid</a><a class="next" href="/2022/09/08/742-Closest-Leaf-in-a-Binary-Tree/">742. Closest Leaf in a Binary Tree</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img src="/img/dark_side_of_the_moon.jpeg"/></a><p>Calm Patient Persistent</p><a class="info-icon" href="mailto:tongxinn@andrew.cmu.edu" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/FelderMountain" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://www.linkedin.com/in/tongxin-niu" title="LinkedIn" target="_blank" style="margin-inline:5px"> <i class="fa fa-linkedin-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Always-Review-Here/">Always Review Here</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode-Notes/">LeetCode Notes</a><span class="category-list-count">329</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Templates/">Templates</a><span class="category-list-count">17</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://leetcode.com/Pinkman_Ox/" title="Pinkman LeetCode" target="_blank">Pinkman LeetCode</a><ul></ul><a href="https://www.youtube.com/watch?v=PLIAp5nr0q0" title="Live Aid (Queen) [1985, London, Wembly Stadium]" target="_blank">Live Aid (Queen) [1985, London, Wembly Stadium]</a><ul></ul><a href="https://www.bilibili.com/video/BV15f4y1p7Gq?spm_id_from=333.337.search-card.all.click&amp;vd_source=36313f6ca20b47d3b8d1740651933b35" title="Hotel California (Eagles) [1994, Hell Freezes Over]" target="_blank">Hotel California (Eagles) [1994, Hell Freezes Over]</a><ul></ul><a href="https://www.youtube.com/watch?v=FcoUvu0mGog" title="Fade to Black (Metallica) [2018, Lincoln, NE]" target="_blank">Fade to Black (Metallica) [2018, Lincoln, NE]</a><ul></ul><a href="https://www.youtube.com/watch?v=Ly6ZhQVnVow" title="Stairway To Heaven (Led Zeppelin) [1975, Live at Earls Court]" target="_blank">Stairway To Heaven (Led Zeppelin) [1975, Live at Earls Court]</a><ul></ul><a href="https://www.youtube.com/watch?v=HUTbH6ywrXk" title="心を開いて (坂井泉水 - ZARD)" target="_blank">心を開いて (坂井泉水 - ZARD)</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Pinkman Tech Space.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Insist on doing small things."><title>Tricks Summary | Pinkman Tech Space</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Tricks Summary</h1><a id="logo" href="/.">Pinkman Tech Space</a><p class="description">Insist on doing small things, then witness the magic</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Tricks Summary</h1><div class="post-meta">2022-08-16<span> | </span><span class="category"><a href="/categories/Always-Review-Here/">Always Review Here</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 18.7k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 70</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>关于写comparator, 小于零代表parameter one小于parameter two; 等于0代表二者相等; 大于0代表parameter one 大于parameter two. 比较a和b(a为第一个参数, b为第二个参数)正序排列一般就是return a – b; 如果要倒序排列则返回b – a, 如果a小于b, 会返回正数也就是告诉Comparator a应该靠后, b靠前. Comparator中如果结果小于0, 那么前者会在排序中靠前, 大于0前者会靠后.</p>
<h2 id="Ascii码中数字-小写字母-大写字母开头"><a href="#Ascii码中数字-小写字母-大写字母开头" class="headerlink" title="Ascii码中数字, 小写字母, 大写字母开头:"></a>Ascii码中数字, 小写字母, 大写字母开头:</h2><p>0是48, A是65, a是97</p>
<h2 id="链表的技巧"><a href="#链表的技巧" class="headerlink" title="链表的技巧"></a>链表的技巧</h2><ol>
<li><p>快慢指针<br>它是的循环条件是fast不为null且fast.next不为null. 当循环结束时, 如果一共有偶数个nodes, 那么slow停在后半部分nodes的第一个; 如果是奇数个, 那么刚好停在正中间那个node.<br>需要注意的是slow和fast在同一起跑线也好,fast比slow往后一个位置出发也好. 如果有cycle, 二者是会碰面的. 但是如果要找到cycle出现的第一个节点, 那么fast需要和slow同一起跑线出发, 这样的话, 等到二者相遇然后把slow重新放到起跑线再让二者移动等到相遇的时候, 那时相遇的点是cycle的第一个节点. 如果一开始fast在slow后一个位置出发, 那么这相当于slow和fast在slow位置前一个位置同时出发, 那么等slow和fast第一次相遇然后把slow重制到开头, 当二者移动再相遇的时候就不是cycle的起始点了, 这里应该把slow重制到开头前一个位置(假想的slow和fast在这一点同时出发). 这点要注意. 因此此时我们应该使用do while. 因为slow和fast要同一点出发, 但我们while循环的一个条件就是slow !&#x3D; fast.</p>
</li>
<li><p>遍历<br>链表中从某个node到达某个node需要的步数<br>假设node 1在node 2的左侧, node 1的index是i, node 2的index 是j. 那么从node 1到node 2需要走的步数是j – i步. 这个可以类推尝试, 比如node 1的index是0, 那么如果node 2的index是1, 需要1步, 是2, 需要两步, 是n, 需要n步. 类似地假设node 1的index是i, node 2的index是i + 1, 此时需要1步, 假设node 2的index是i + 2, 需要2步, 假设node 2的index是i + m &#x3D; j, 那需要j – i步.</p>
</li>
</ol>
<p>这个结论对于rotate list相关的题很有用. 比如61题. 移除后k个, 那么如果我想到达倒数k + 1个位置. 那么要从head走多少步? 前面一共有count – k个node. 那么倒数k + 1个node的index为count – k – 1(假设head的index是0), 那么从head就需要走count – k – 1步即可. for循环中i &#x3D; 0, i &lt; count – k – 1即可.</p>
<h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a>Arrays.asList()</h2><p>Arrays.asList() 传数组, 变成List. 或者传进去element也行比如这样:<br>List<Integer> list &#x3D; Arrays.asList(1, 2, 3);<br>最后出来的list包含1, 2, 3.<br>需要注意的是:<br>Using this method, we can convert from an array to a fixed-size List object. This List is just a wrapper that makes the array available as a list. No data is copied or created.<br>Also, we can’t modify its length because adding or removing elements is not allowed.<br>However, we can modify single items inside the array. Note that all the modifications we make to the single items of the List will be reflected in our original array<br>也就是用Arrays.asList出来的东西只是在array外面包了层壳, 使我们可以用List的方式去访问, 但是我们不能添加删除东西, 同时对元素的改变也会反映在原array中.<br>一个例子:<br>如果需要新new出来一个list, 我们使用ArrayList(Arrays.asList(array))<br>Similar to the Arrays.asList method, we can use ArrayList&lt;&gt;(Arrays.asList(array)) when we need to create a List out of an array.</p>
<p>But, unlike our previous example, this is an independent copy of the array, which means that modifying the new list won’t affect the original array. Additionally, we have all the capabilities of a regular ArrayList, like adding and removing elements:<br>此时出来的arraylist, 就是全新的, 我们对新的list更改也不会改变原有的array, 我们此时也可以add和delete元素.</p>
<h2 id="给一个数组-每个元素是个数字代表一位-从高位到低位-左到右-遍历得到这个数组表示的值"><a href="#给一个数组-每个元素是个数字代表一位-从高位到低位-左到右-遍历得到这个数组表示的值" class="headerlink" title="给一个数组, 每个元素是个数字代表一位, 从高位到低位(左到右)遍历得到这个数组表示的值"></a>给一个数组, 每个元素是个数字代表一位, 从高位到低位(左到右)遍历得到这个数组表示的值</h2><p>result &#x3D; result * 10 + digit;<br>result是存最后结果的变量, 我们边遍历数组边更新result; digit则是某个位置的digit. 比如一个数字是223. 从最左边开始, result一开始为0, 此时我们可以得到0 * 10 + 2 &#x3D;&#x3D; 2. 然后到达下一个2, 此时result变为 2 * 10 + 2 &#x3D;&#x3D; 22. 然后到3, 此时result变为22 * 10 + 3 &#x3D;&#x3D; 223. 非常好.<br>如果给的是个string, 那么digit &#x3D; s.charAt(pos) – ‘0’. pos表示string中的某个index.</p>
<h2 id="用-10方法从高位到低位还原数字的时候-如何大数clamp到Integer-MAX-VALUE-小的数clamp到Integer-MIN-VALUE"><a href="#用-10方法从高位到低位还原数字的时候-如何大数clamp到Integer-MAX-VALUE-小的数clamp到Integer-MIN-VALUE" class="headerlink" title="用*10方法从高位到低位还原数字的时候, 如何大数clamp到Integer.MAX_VALUE, 小的数clamp到Integer.MIN_VALUE"></a>用*10方法从高位到低位还原数字的时候, 如何大数clamp到Integer.MAX_VALUE, 小的数clamp到Integer.MIN_VALUE</h2><p>在我们进行result  &#x3D; result * 10 + digit之前需要进行一个判断(判断执行这个*10 + digit的语句会不会overflow):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ans &gt; Integer.MAX_VALUE / <span class="number">10</span> || (ans == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; currentDigit &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">    <span class="comment">// Overflow upper limit, do something here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; Integer.MIN_VALUE / <span class="number">10</span> || (ans == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; currentDigit == -<span class="number">9</span>)) &#123;</span><br><span class="line">    <span class="comment">// Overflow lower limit, do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要判断的是现在的result在乘完10之后加digit是否会overflow. 因为有overflow的风险, 我们不能直接算这个结果再和Integer.MAX_VALUE比. 如果result是long, 那没有问题. 因为long的话就不会overflow. 此时如果比Integer.MAX_VALUE大, 并且此时这个数组表示的数字是正的, 那么肯定超过int的最大值, 于是clamp到int的最大值. 如果数组表示的数字是负数, 那么这个数的绝对值最小是|Integer.MIN_VALUE|, 那么此时虽然可能没有overflow(刚好是|Integer.MIN_VALUE|), 但是也没必要再往下加了, 此时直接返回clamp到最小值即可.</p>
<p>如果不让用int类型的result, 那么就看上面的那个code snippet. 分三种情况, Integer.MAX_VALUE &#x2F; 10是分水岭. 第一种就是result大于Integer.MAX_VALUE &#x2F; 10, 此时result * 10就肯定超过, 直接clamp到int最大值就完事儿. 第二种情况是result &#x3D;&#x3D; Integer.MAX_VALUE &#x2F; 10, 此时需要分情况. 如果result &#x3D;&#x3D; 214748364, (提醒一下Integer.MAX_VALUE是:2147483647), 并且digit是8或9也就是大于Integer.MAX_VALUE最小的那一位7, 那么result * 10 + digit就变为2147483648或者2147483649, 此时也是大于Integer.MAX_VALUE的. 最后一种就是result &lt; Integer.MAX_VALUE &#x2F; 10, 此时result * 10 + digit肯定不会overflow, 因为在这个范围内, result最大能取到的就是214748363, 也就是比Integer.MAX_VALUE &#x2F; 10少个1. 那么此时result * 10即使加个9也才2147483639, 还差一点儿. </p>
<p>综上, 如果能用long表示result, 直接判断是否大于Integer.MAX_VALUE, 如果不能只能用int表示, 就看results是否大于Integer.MAX_VALUE &#x2F; 10或者是否result等于Integer.MAX_VALUE &#x2F; 10并且digit &gt; Integer.MAX_VALUE % 10).</p>
<h2 id="一个满树-深度是n层处有多少node"><a href="#一个满树-深度是n层处有多少node" class="headerlink" title="一个满树, 深度是n层处有多少node"></a>一个满树, 深度是n层处有多少node</h2><p>深度是0时是1个, 1时是2个, 2是是4个, 3时是8个… 可以认为每一层代表二进制数的一位. 0层是least significant bit. 越往下越大. 因此深度是n时, 这一层的node数是2^n个. 一共有多少个node呢? 如果给定了height, 那么总数就是(2^height) – 1个. 因为height是从1开始数的. 到最后一层假如是n, 那就说明深度是n – 1. 此时二进制数中0到n – 1位都是1, 于是这个值就等于(2^n) – 1.</p>
<h2 id="如何遍历一个map"><a href="#如何遍历一个map" class="headerlink" title="如何遍历一个map"></a>如何遍历一个map</h2><p>比如一个变量map里装的是Integer和List<Integer> pairs, 那么遍历的写法就是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// other code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何iteratively-in-order-traverse-a-BST-with-DFS"><a href="#如何iteratively-in-order-traverse-a-BST-with-DFS" class="headerlink" title="如何iteratively in-order traverse a BST with DFS"></a>如何iteratively in-order traverse a BST with DFS</h2><p>看LC 230题的题解.</p>
<h2 id="如何代码写的简洁"><a href="#如何代码写的简洁" class="headerlink" title="如何代码写的简洁"></a>如何代码写的简洁</h2><p>合并一些重复的代码. 就如rotated sorted array那道题. 关于target和middle是否在同一侧, 我们进行了分类讨论. 不管哪一种情况, 我们最终都要移动low或者up. 这样就会出现重复的代码. 因此有没有什么方法可以让这两种情况适用一种逻辑呢? 我们使用了一个中间变量num, 如果target和middle在同侧, num就等于nums[middle], 然后根据binary search的那一套(nums[middle]和target比)去移动low或者up. 如果不在同侧, 我们强行让num等于某个值(这个值算是一个signal, 表明出现了不同侧情况. 我们让这个值也满足我们之前写的逻辑), 然后按照binary search的那一套同样可以正确地移动low或者up.</p>
<p>但是这样合并的情况就会使代码的可读性和理解性变低.</p>
<h2 id="思考问题的角度"><a href="#思考问题的角度" class="headerlink" title="思考问题的角度"></a>思考问题的角度</h2><p>有时候我们会在想自己的逻辑是否能够应对edge case. 然后我们会绞尽脑汁开始想edge cases都有哪些可能. 我们不妨换种思路, 看看有没有什么好的角度能够证明我们的逻辑都能够覆盖哪些情况. 或者用数学的方法, 假设case的一些条件, 然后用逻辑去推理, 看自己写的代码能否满足我们的要求.</p>
<h2 id="Backtrack"><a href="#Backtrack" class="headerlink" title="Backtrack"></a>Backtrack</h2><p>其实就是可以提前返回的DFS. 同时backtrack要记录一些状态, 如果达到某些条件则选择继续或者直接返回. DFS则是走遍所有的路. 其实backtrack还是DFS.<br>递归的一般结构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (some conditions) &#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">  recursion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯的一般结构:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> currState)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (currState == edgeState) &#123;</span><br><span class="line">    <span class="comment">// store current state or output current state</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123; <span class="comment">//Traverse all possibilities at current pos</span></span><br><span class="line">    <span class="comment">// some code here change the global state</span></span><br><span class="line">    backtrack(nextState);</span><br><span class="line">    <span class="comment">// some code here change the global state back</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个回溯模板确实好用. 修改全局变量然后恢复全局变量就是permutation, sudoku这些的做法. 括号的组合等等也是这样的. 这种问题我们都是假设在某个条件下(比如permutation的前几位已经确定的条件下), 剩下可能的路走一遍并把所有走到头的情况下那时全局变量的状态给存起来. Permutation就是这样的, 当所有的位置都确定了是什么字符的时候, 就存起来这个.</p>
<p>知乎关于递归, DFS, Backtrack, 动态规划的回答:<br>递归就是自我调用，经常作为一种编程的实现方式，比如题主问题中的DFS 、动态规划、回溯法都可以用递归来实现，当然也可以用非递归来实现。很多时候一个概念也可以用递归的方式来定义（比如gnu）。回溯是一种通用的算法，把问题分步解决，在每一步都试验所有的可能，当发现已经找到一种方式或者目前这种方式不可能是结果的时候，退回上一步继续尝试其他可能。很多时候每一步的处理都是一致的，这时候用递归来实现就很自然。当回溯用于树的时候，就是深度优先搜索。当然了，几乎所有可以用回溯解决的问题都可以表示为树。那么这俩在这里就几乎同义了。如果一个问题解决的时候显式地使用了树，那么我们就叫它dfs。很多时候没有用树我们也管它叫dfs严格地说是不对的，但是dfs比回溯打字的时候好输入。别的回答里提到了砍枝，实际上这二者都可以砍枝。至于动态规划，被题主放到这里是因为都是竞赛中经常会遇到并且学起来不容易明白吗？回溯可以用于所有用穷举法可以解决的问题，而DP只用于具有最优子结构的问题。所以不是所有问题都适合用dp来解决，比如八皇后。dp需要存贮子问题的解，回溯不需要。</p>
<p>作者：Jerron<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/266403334/answer/698464437">https://www.zhihu.com/question/266403334/answer/698464437</a><br>来源：知乎</p>
<p>不管是递归还是回溯, 都是假设递归函数的功能, 然后通过调用它来实现我们想要的功能, 进而完成递归函数逻辑的书写. 也就是实现一个递归函数的功能需要这个递归函数的功能.</p>
<h2 id="递归函数终止条件"><a href="#递归函数终止条件" class="headerlink" title="递归函数终止条件"></a>递归函数终止条件</h2><p>在DFS中就很自然了, 不能一直往下走, 总要到什么地步就停下来然后返回.</p>
<p>递归函数的终止条件可以是在开头写一个终止条件. 也可以在调用某个递归函数前判断是否要继续调用. 前者会有压栈pop栈的过程, 消耗较大, 后者则消耗更少. 见combination sum这道题在递归函数中for循环的判断条件作为一个例子.</p>
<h2 id="putIfAbsent-key-value"><a href="#putIfAbsent-key-value" class="headerlink" title="putIfAbsent(key, value)"></a>putIfAbsent(key, value)</h2><p>这个method好啊, 见别人用到过. 它等同于:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> map.get(key);</span><br><span class="line"><span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">  v = map.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>就是红黑树. 每个node存的是键值对构成的entry, 按照key的大小排序(或者自定义排序方法, 使用comparator来说明排序方式). 然后我们可以在时间复杂度为O(logn)的前提下取到某个给定的key对应的value. 比如那个Time Based Key-Value Store那道题. 我想的是有一个hashmap, key是timestamp, value呢是一个hashmap, 这个inner hashmap存的是某个timestamp下的string, string这样的key value pair. 现在的问题就是如果我们想要得到某个string在某个timestamp下对应的value, 那该怎么办呢? 按照我的操作, 就是先看有没有这个timestamp, 有的话再看在该timestamp下有没有该string作为key的KV pair. 没有的话, 从timestamp开始向下遍历(timestamp – 1, timestamp -2…一直找到timestamp是1的情况, 因为最小就是1)外部的map的timestamp, 去寻找每种timestamp的inner map是否包含该string作为key的KV pair. 这样就会很慢.</p>
<p>试着想一下另一种嵌套方式. 用String-String pair的key作为外层map的key, 外层map对应的value呢是一个hashmap, inner hashmap则是timestamp和string-string pair中的value组成的pair.  于是我们给定一个string-string key value pair以及timestamp, 我们首先看这个string key是否存在, 不存在的话, 等于是在任何timestamp下都没有插入过该string-string pair. 如果存在, 我们找到这个key对应的hashmap, 这个map中呢存的是各种timestamp下以该string  key对应的value的值. 此时又有一个问题, 如果刚好我们要的timestamp存在那还好, 直接访问到返回即可, 如果没有呢? 就要遍历整个inner map来找到最接近现在timestamp值的那个entry(该entry中的timestamp最接近我们想要的timestamp, 这是题目的要求)了, 因为这个hashmap的entry不是按照timestamp排好序的. </p>
<p>此时TreeMap就派上用场了. TreeMap就能把给定的键值对按照键的大小(键的大小可以根据natural ordering也可以根据我们提供的comparator)来排序并且可以在log(n)时间获得某个key对应的value. 于是如果inner map存在我们想要的timestamp, 那么直接获取, 如果没有, 那么获取此时存有的最大的timestamp即可. 毕竟红黑树就是个BST, 那么获取树中最大的timestamp也就是需要log(n)时间.</p>
<p>除了可以使用TreeMap, 我们还有别的方法. 我们忽略了一个点, 就是这道题有说过timestamp的值是不会递减的. 也就是后插入的timestamp不会比前面小. 也就是对于某个KV pair, 我们先插入K, V1(timestamp1), 后插入K, V2(timestamp2), timestamp2是不会小于timestamp1的. 于是我们的inner map可以换成List. list中存的还是timestamp-string pair, 按照题目的说话, timestamp只会越来越大不会变小, 那么这个list就是sorted了, 因为是先来后到, 对于同一个string key后插入的就会在list的后面. 对于sorted list, 想要查找某个值, binary search就自然而然被想到了. 先使用binary search找我们想要的timestamp, 如果有的话就返回它, 没有的话返回list中最后一个element中的value即可.</p>
<h2 id="Binary-Search变种-1-找某个target-找不到就找比它小的数字中最大的那个-如果还找不到返回-1"><a href="#Binary-Search变种-1-找某个target-找不到就找比它小的数字中最大的那个-如果还找不到返回-1" class="headerlink" title="Binary Search变种(1):找某个target, 找不到就找比它小的数字中最大的那个, 如果还找不到返回-1."></a>Binary Search变种(1):找某个target, 找不到就找比它小的数字中最大的那个, 如果还找不到返回-1.</h2><p>除了常规的binary search(找到就找到, 找不到就返回-1), 还有一个变种就是如果找不到target, 返回比它小的数字中最大的那个数字的index. 如果没有比它小的, 返回-1(因为-1不可能是index的值):</p>
<p>需要改变的就是有个result变量, 初始值为-1(很关键, 因为可能整个list的值都比target大, 此时result值在全程都不会被更新, 这就说明没有比target还小的值). 每当left移动时, 更新result为当前middle的值. 到最后返回result的值即可.</p>
<p>这个模板需要牢记. 小中大(比target小的数字中最大的)左(left移动时记录), 大中小(比target大的数字中最小的)右(right移动时记录).</p>
<p>这个逻辑就是result始终处于left的左侧. 只要left更新, 那它就会变为middle + 1. 此时result变为middle也就是更新后left的左侧一格. 如果right更新, 那left和result都不会变. 这样的话我们就看最后结束循环left和right的位置是如何的.<br>1.	Left和right重合并且left移动, 此时是middle(left和right也在这里)指向的值小于target, 更新result到middle的位置(也就是此时left的位置), 然后更新left位置, 之后循环结束. 我们知道right右边的值一定比target要大. 此时left来到了right后面一格子, result在left左侧一格, 此时就出现result指向的数字小于target, left更新后指向的数字大于target. 此时的result指向的是比target小的数字中最接近target的值了.<br>2.	Left和right重合并且right移动, 此时middle指向的值(left和right也在这里)大于target. 假设之前result由于left移动过, 那么此时result指向的值是小于target的, 然后此时left和right重合指向的值是大于target的, 于是result也一样是指向比target数字小的数字中最接近target的值了. 如果left一直没动过, result则为-1. 此时也满足我们的要求(此时所有的数字都大于target, 我们需要返回-1).<br>3.	Left和right挨着, right更新, 此时是middle(left的所在位置)大于target和2其实是一样的道理, result指向的值小于target而left指向的值大于target, 于是result依然指向比target小的数字中最大的数字.<br>综上这个逻辑是正确的.</p>
<p>***我们也要记住这三种结束循环前的情况:<br>Left和right重合, 二者其中一个更新导致循环结束以及left和right挨着, right更新导致循环结束.</p>
<hr>
<h2 id="Binary-Search变种-2-找某个index-指向的数字等于target-但是左边就比target小或者出界-类似地-找某个index-指向的数字等于target-但是右边就比target大或者出界-这两个index之间都等于target-包含两个index指向的数字"><a href="#Binary-Search变种-2-找某个index-指向的数字等于target-但是左边就比target小或者出界-类似地-找某个index-指向的数字等于target-但是右边就比target大或者出界-这两个index之间都等于target-包含两个index指向的数字" class="headerlink" title="Binary Search变种(2): 找某个index, 指向的数字等于target, 但是左边就比target小或者出界; 类似地, 找某个index, 指向的数字等于target, 但是右边就比target大或者出界. 这两个index之间都等于target(包含两个index指向的数字)"></a>Binary Search变种(2): 找某个index, 指向的数字等于target, 但是左边就比target小或者出界; 类似地, 找某个index, 指向的数字等于target, 但是右边就比target大或者出界. 这两个index之间都等于target(包含两个index指向的数字)</h2><p>这个方法和上面的变种类似, 也是找个变量记录当前知道的最好的答案, 直到循环结束, 我们可以得到最终的答案.<br>找左边起始:</p>
<p>找右边起始:</p>
<p>想知道比某个数字小的数字中, 最大的那个数字:</p>
<h2 id="Binary-Search变种-3-我们知道我们想要的某个符合我们筛选条件的值一定存在于给定的array中-此时使用left-lt-right策略"><a href="#Binary-Search变种-3-我们知道我们想要的某个符合我们筛选条件的值一定存在于给定的array中-此时使用left-lt-right策略" class="headerlink" title="Binary Search变种(3) 我们知道我们想要的某个符合我们筛选条件的值一定存在于给定的array中, 此时使用left &lt; right策略."></a>Binary Search变种(3) 我们知道我们想要的某个符合我们筛选条件的值一定存在于给定的array中, 此时使用left &lt; right策略.</h2><p>比如658题K closest elements. 我们知道一定有一个index作为start, 然后往后框k个数字(包括自己), 这k个数字是最小的. 于是此时我们不断地缩小范围, 直至left &#x3D;&#x3D; right, 此时指向的数字就是我们最终的答案. 对于这道题, 我们的收缩条件是看x - A[mid]和A[mid + k] – x的大小. 最终的答案区间一定满足A[start] &lt;&#x3D; A[start + k](start + k不出界的前提下). 如果小于的话, 至少我们能找到一个元素距离K更近, 因此此时框起来的区间不是答案. 当然满足这个条件的也不一定是答案, 但答案一定满足这个条件. 我们接着看判定的条件, 如果左边大, 说明此时mid距离k更远, 此时mid肯定不能是start, 因为mid + k这个位置出现了更小的, 而我们要求的是把k个最小的都框进去, 于是我们让left更新为mid + 1. 如果左右相等, 此时的mid可能是答案因为符合我们之前讨论的答案的特征, 但不确定, 因为可能mid左侧的值始终不变, mid + k左侧一个和mid + k相等 那么框住mid左侧的一个比框住mid + k左侧的一个要好, 因为题目是说如果两个位置距离x的距离一样, 那么小的那个算距离的更近. 于是我们先保留, 让right &#x3D; mid. 注意此时mid右侧肯定都不是答案, 因为往右走mid会更接近x, mid + k会距离x更远, 这样的情况虽然符合最终答案的特征, 但是我们知道还有更好的答案, 也就是现在的状态(左右相等). 于是我们应该往左走. 如果出现右边大, 那说明此时mid可能是答案, 但不确定, 需要往左走看看有没有更合适的. 因此我们的答案就出来了.</p>
<p>本质就是让可能是答案的位置始终在sliding window里面, 直到最后角逐出最后一个.</p>
<h2 id="数字字符转对应的int值-字母字符在长度为26的数组中被map到的位置"><a href="#数字字符转对应的int值-字母字符在长度为26的数组中被map到的位置" class="headerlink" title="数字字符转对应的int值, 字母字符在长度为26的数组中被map到的位置"></a>数字字符转对应的int值, 字母字符在长度为26的数组中被map到的位置</h2><p>比如这个数字字符叫做digitCharacter, 我们直接digitCharacter – ‘0’即可. 类似地, 如果用一个长度为26的int数组存储一个字符串中遇到的字母字符的出现频率, 如何让每个字母都map到它对应的位置, 比如a的频率存在第0个位置, b的频率存在第1个… z频率存在第25个. 我们直接用该字母字符减去‘a’即可. 假设这个字母字符为letterCharacter, 那么它的频率存在该数组中的letterCharacter – ‘a’这个位置(0-indexed array).</p>
<h2 id="关于数组clone的问题"><a href="#关于数组clone的问题" class="headerlink" title="关于数组clone的问题"></a>关于数组clone的问题</h2><p>实验了一波, 明白了. clone和copyOf都是对于一维数组的deep copy, 如果直接给个二维数组, 那么最后都会只是shallow copy. 因此我们需要用循环, 一行一行的copy一个二维数组. 看下面的例子:</p>
<h2 id="Substring的时间复杂度"><a href="#Substring的时间复杂度" class="headerlink" title="Substring的时间复杂度:"></a>Substring的时间复杂度:</h2><p>O(n), n是substring的长度.</p>
<h2 id="HashSet和Trie"><a href="#HashSet和Trie" class="headerlink" title="HashSet和Trie:"></a>HashSet和Trie:</h2><p>简单来说HashSet生成hash去找某个string也需要时间, 而且是和给的string的长度有关的, 而Trie可以在早些时刻终止寻找而不需要看完一个string的所有字符.</p>
<h2 id="如何DFS有cycle的graph或者DFS但是避免走之前走过的node"><a href="#如何DFS有cycle的graph或者DFS但是避免走之前走过的node" class="headerlink" title="如何DFS有cycle的graph或者DFS但是避免走之前走过的node"></a>如何DFS有cycle的graph或者DFS但是避免走之前走过的node</h2><p>使用一个visited set来存走过的node. 在继续DFS前, 先看即将要去的node是否被visited过, 没有再继续DFS, 否则直接换路. 就拿clone node那道题来说, DFS的时候可能会遇到neighbor被visited过的情况, 这种情况的出现就是要么这个neighbor在栈中已被调用也就是在我们所在的栈的上方, 要么是这个neighbor已经完成了添加所有neighbor的操作. 不管哪种情况, 我们都不需要再额外创建一个node, 直接返回这个创建好的即可.</p>
<p>DFS带cycle的graph我们需要visited这种机制来避免走走过的地方. 这有点儿像人为的划分路线. 我们边走边往visited里面更新走过的node. 当我们在某个时候遇到visited里面的node的时候, 表示这个node已经来过, 不应该再走这里, 于是我们返回再走别的neighbor.</p>
<h2 id="找递归的base-case如何找"><a href="#找递归的base-case如何找" class="headerlink" title="找递归的base case如何找"></a>找递归的base case如何找</h2><p>我的观察是看递归函数的parameter都有哪些, 挨个去看这些parameter并试一下每个parameter不同的input, 想一想什么情况下会出现这种input, 然后决定是否是base case, 如果是的话就记录下来.</p>
<h2 id="二维dp转一维dp"><a href="#二维dp转一维dp" class="headerlink" title="二维dp转一维dp"></a>二维dp转一维dp</h2><p>Unique path那道题转1D dp的思路是个好方法.</p>
<h2 id="Sliding-Window"><a href="#Sliding-Window" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><p>在类似sliding window的题中, 不要一步到位, 让一个left和right一次走太多, 走一步看一步是比较好想思路的. 看76题.</p>
<h2 id="gt-gt-和-gt-gt-gt"><a href="#gt-gt-和-gt-gt-gt" class="headerlink" title="&gt;&gt;和&gt;&gt;&gt;"></a>&gt;&gt;和&gt;&gt;&gt;</h2><p>&gt;&gt;是signed right shift, 左侧会补之前在这个位置的值. 比如如果最左侧是1, 那么right shift一位, 最左侧还是1. 1000变为1100. &gt;&gt;&gt;是unsigned就是不管最左侧是什么, 统一填0. 1000变为0100.</p>
<h2 id="想要理解递归-就要跟着递归走一遍"><a href="#想要理解递归-就要跟着递归走一遍" class="headerlink" title="想要理解递归, 就要跟着递归走一遍."></a>想要理解递归, 就要跟着递归走一遍.</h2><p>有时候确实是需要跟着递归走一走才能明白为什么可以这么写, 知道后记住这么写有什么效果就行. 比如permutation那个模板, swap然后helper然后swap, 这样来得时候什么样, 回来还什么样.</p>
<h2 id="Linked-List快慢指针"><a href="#Linked-List快慢指针" class="headerlink" title="Linked List快慢指针"></a>Linked List快慢指针</h2><p>循环的条件是fast !&#x3D; null并且fast.next !&#x3D; null. 如果最终fast &#x3D;&#x3D; null, 表示list一共偶数个nodes; 如果fast最终它的next是null, 这表示list一共有奇数个nodes.<br>如果是list有偶数个nodes, slow会停在后半部分最前面的node处. 因为fast跳一次就能经历2个, 假设它跳了n次到达null, 它左侧(所经历过的)有2n个. Slow也是移动了n次, 从第一个移动到第n + 1个. 于是slow的左边有n个, 右边有n – 1个, slow也就是后半部分的头一个.<br>如果是list有奇数个nodes, slow会停在正中间. 一样的道理, fast最终跳了n次, 停在了最后一个node处, fast身后有2n个nodes, 一共有2n + 1个nodes. 因为slow也跳了n次, 那么slow在n + 1个node处. Slow左侧有n个, 右侧有n个.</p>
<h2 id="写循环"><a href="#写循环" class="headerlink" title="写循环"></a>写循环</h2><p>我们写循环通常是要在某个范围内的, 比如数组范围内, 字符串范围内. 在此之上, 我们可能还有些别的条件之类的. 我们会开始思考循环停止的时候会有哪些情况. 我们可以这么想, 我们是在某个范围内去干某件事, 当循环停止时, 要么是我们想干的事情干成了, 要么就是出界了. 分成这两种大情况也许会好思考逻辑一些. 见844题. 我们找一个不能被抵消的字符, 条件首先是要在string的范围内, 其次是此时没有#可以用来抵消字符, 如果都不满足我们停止. 当循环停止无非就是两种情况, 一种是我们出界了也没找到这样的字符, 或者就是我们找到了一个字符, 此时#的count由于是0, 因此不能再抵消字符, 这两种情况也被反映在我们对ansOne和ansTwo赋值的判断上.</p>
<h2 id="String-array是如何被sort的"><a href="#String-array是如何被sort的" class="headerlink" title="String array是如何被sort的"></a>String array是如何被sort的</h2><p>是一个一个char比较的. 先比较最左边的char按照ASCII码去比较. 如果这一位相同再比较下一位, 直到分出大小. 如果一个string下一位没了而另一个string和它前几位都相同但是后面还有, 那么前者(短的)就被认为是更小的.</p>
<h2 id="String的indexOf"><a href="#String的indexOf" class="headerlink" title="String的indexOf"></a>String的indexOf</h2><p>我们可以传入一个char或者一个string以及一个起始点, 从起始点开始找, 返回第一次我们给定的char或者string出现的位置, 如果没找到, 返回-1.</p>
<h2 id="BFS的注意"><a href="#BFS的注意" class="headerlink" title="BFS的注意"></a>BFS的注意</h2><p>就是在while q not empty进入循环后, 如果我们需要记录level的情况, 比如想知道现在是在哪个level了, 或者像1730那道题, 一个level遍历完我们要让distance + 1, 这种情况记得刚进去while循环后记录此时的length. 然后在内部循环length次从而让该level的node都被遍历到但是下一level新添加进来的nodes不会被遍历到.</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>我们搜索一个word中的某个字符比如第n个字符的时候, 默认前n – 1个字符都存在于prefix tree中, 也就是一路从root到某个node, 包含了前n – 1个字符, 于是当我们要判断第n个字符在不在的时候, 我们需要从第n – 1个字符对应的trie node处去看, 看看它的下一个字符中有没有第n个字符. 因此搜索一个字符都是从上一个字符对应的trie node开始的(也就是从root开始搜寻第0个字符, 搜到了然后进入第0个字符对应的node, 然后去搜寻第一个字符, 搜寻到了, 进入第一个字符对应的trie node然后搜寻第二个字符… 以此类推, 一直搜到了第n – 1个字符, 我们进入其对应的trie node然后去搜寻第n个字符).</p>
<h2 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h2><p>以后看到这个的时候, 我们应该想到binary search或者sort, 因为如果n个元素, 每个元素都用binary search那就是nlogn了. 如果是sort, 更不用说了, 就是nlogn.</p>
<h2 id="Anagrams"><a href="#Anagrams" class="headerlink" title="Anagrams"></a>Anagrams</h2><p>Anagrams说白了就是按频率说话. Anagrams之间, 每个字符出现的频率是固定的, 只是排列组合造成了anagrams. 比如badd和abdd互为anagrams, 它们都是a出现1次, b出现1次, d出现两次, 只是这些字母的排列组合造成了anagrams的现象. 因此如何去identify一种anagram? 看它每个字符出现的频率, 也就是用一个array去存每个字符出现的频率. 比如假设word都是小写字母, 那么我们可以用长度为26的char array去存每个字符出现的频率, 到时候直接把这个char array给到String, 这样就生成了一个该anagram专有的string, 可以存到map中, 如果后面的word有同样的key, 就说明二者互为anagrams.<br>如果两个word它们这样的array一模一样(每一个元素的值相同, 代表这个元素表示的字符出现的频率相同), 那么这两个word就互为anagram.</p>
<h2 id="Map-values"><a href="#Map-values" class="headerlink" title="Map.values()"></a>Map.values()</h2><p>它可以直接扔给一个: <code>new ArrayList&lt;&gt;(map.values());</code><br>想只获得key就是: <code>map.keySet();</code><br>想只获得value就是: <code>map.values();</code></p>
<h2 id="Clone-graph"><a href="#Clone-graph" class="headerlink" title="Clone graph"></a>Clone graph</h2><p>Clone graph那道题的DFS方法就相当于DFS遍历一遍graph. 每次遇到新的node就new出来一个, 遍历的目的就是走遍每一个node, 到一个node就new一个, 如果发现某个node new过了, 那么就不再沿着这条路走该换其他, 直到所有的路都走完. 从一个node出发往其他neighbors走, 到达某个neighbor时会该neighbor会和它建立edge, 当从该neighbor返回时, 它又和自己的这个neighbor node建立edge.<br>每个node都是这样. 每个node都会被压入栈, 压入栈意味着执行递归函数中的内容, 该node会走向每一个neighbor, 如果neighbor被new了那就直接指向, 不用担心neighbor不会指向自己, 因为每个node都会被压入栈, 从而指向它们的neighbors. DFS回来时自己指向neighbor, DFS出发后自己的neighbors会指向自己.</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>循环表示我们要把某些步骤重复做, 这代表着要么是一开始有个初始状态进入循环, 要么是已经循环了几次我们又进入循环. 因此每次进入循环就这两种状况. 通常再次进入循环可以看做是以现在的条件初次进入循环, 和第一种情况一样. 因此有时候不需要区分先进入循环和后进入循环的情况. 这个思想需要知道.</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>做到decode string那道题, 发现递归的一些本质. 本质就是栈桢, 里面可以存储数据, 变量. 当我们遇到左括号时, 我们需要先知道括号里的string是什么, 于是先把目前构建好的string保存在目前的栈桢中, 然后调用递归函数来去构建括号里面的东西, 等构建完成后, 我们返回, 此时之前构建好的string还保存的好好的, 我们继续构建即可. 参照basic calculator那道题, 也是同样的道理. 递归函数就是遇到某个情况不能解决, 需要存一下当前的一些值然后继续调用递归函数来去完成subproblem, 等把subproblems解决完后回到之前的递归函数此时就能够完成任务了.</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>如果是在原来的矩阵上进行改变, 那么什么时候改变呢? 是压入queue之前, 还是在queue中取出来后再改变?</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS返回值这个东西可以认为是如果下面遇到了什么特殊情况, 我们就需要把这个情况一直往上传. 于是我们在调用的递归函数后运行完毕后可以看一看传递给我们的有没有要继续向上传递的消息, 如果有要把这个情况考虑, 没有的话就不用传话, 直接返回. 1254这道题就是. 如果遇到边界情况了, flag就会是false然后返回上层, 上层看到递归函数结束后就要看是否有flag有false的情况, 如果有的话要及时把自己的flag也设置为false然后向上传递.</p>
<h2 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h2><p>The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.<br>也就是PriorityQueue里面的elements默认是从小到大根据natural ordering去排. 或者我们提供Comparator去排. poll(), peek()都是看头部也就是最小的或者根据我们的Comparator排在最靠前的. 注意的是如果我们获得iterator(), 它并不会按照order给我们去iterate, 想要去按顺序iterate, 就需要这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(pq.toArray());</span><br></pre></td></tr></table></figure>

<h2 id="什么时候用栈"><a href="#什么时候用栈" class="headerlink" title="什么时候用栈?"></a>什么时候用栈?</h2><p>Whenever I see a problem, where past inputs affect the current input, and I can’t get to past inputs without stepping back through each step, I think of stacks.<br>这是735题下面bodet这个人的评论的reply里harrytheape的回答. 我觉得说得很到位. 如果之前的input对现在的结果有影响, 并且我还不能知道之前的input, 那么就会考虑使用栈把之前的inputs存起来.</p>
<h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置:"></a>矩阵的转置:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">    <span class="comment">// swap matrix[i][j] and matrix[j][i]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体见48题.</p>
<h2 id="Graph中的node"><a href="#Graph中的node" class="headerlink" title="Graph中的node"></a>Graph中的node</h2><p>Graph中的node可以看做是一个entry, 该node的value和其children构成的set组成的entry.</p>
<h2 id="比较数轴上的两个数字哪个距离某个值更近"><a href="#比较数轴上的两个数字哪个距离某个值更近" class="headerlink" title="比较数轴上的两个数字哪个距离某个值更近"></a>比较数轴上的两个数字哪个距离某个值更近</h2><p>假设array[i] &lt; array[j], 那么如果想知道二者哪个距离数字x更近, 用下面这个公式:<br>x – array[i] 和array[j] – x进行比较. 谁小, 谁离x更近. 假设x在array[i]的左侧, 那么肯定距离array[i]更近, 此时x – array[i]是负数, array[j] – x是正数, 我们得到左侧小, 符合我们array[i]更近的判断. 如果x在array[j]的右侧, 那么肯定距离array[j]更近, 此时x – array[i]大于0, array[j] – x小于0, 右侧小, 符合我们array[j]距离x更近的判断. 如果x在array[i]和array[j]之间, 那么此时左右都是大于0的, 看谁小就说明距离谁近.<br>假设array[i] &#x3D;&#x3D; array[j], x如果在array[i]左侧, 我们认为是array[i]更近, 如果x在array[j]右侧, 我们认为array[j]距离更近, 如果x等于array[i]和array[j], 我们认为一样近. 当然我们如果不想这样认为, 比如x在array[i]左侧想认为array[j]更近, 那么我们可以加个if, 来处理array[i] &#x3D;&#x3D; array[j]的情况.<br>来自658题的启发.</p>
<h2 id="关于DP要声明数组长度的问题"><a href="#关于DP要声明数组长度的问题" class="headerlink" title="关于DP要声明数组长度的问题"></a>关于DP要声明数组长度的问题</h2><p>以139题为例, 是要声明长度为s.length()的数组呢还是s.length() + 1呢? 其实我们可以看一下我们的诉求是什么. 在某个位置n, 我们想知道从第0个位置到第n个位置(两头均inclusive)是否能构成word break, 我们首先看能否直接构成一个word, 即[0, n]能否构成, 如果不能我们再看[0, 1), [1, n]能不能构成, 以此类推, 直到最后[0, n), [n, n]能不能构成, 那么[0, 1), [0, 2), [0, 3)…就代表着不同的状态. 于是我们可以规定dp[n]代表[0, n)是否能构成word break. 因此我们想要知道的是[0, s.length())能否构成, 于是为了满足下表index表示的就是[0, index)是否能构成word break, 我们声明s.length() + 1长度. 那么问题来了dp[0]应该给true还是false呢? 不妨看一下我们判定一个位置是否构成word break需要走的流程, 某个位置n对应的dp[n]先看是否[0, n)自己就是word, 如果不行, 那么看dp[1] &amp;&amp; dict.contains(s.substring(1, n))是否满足, 如果不行再看dp[2] &amp;&amp; dict.contains(s.substring(2, n))是否满足以此类推. 此时最开始可以看做是dp[0] &amp;&amp; dict.contains(s.substring(0, n)), 由于我们此时只看后者, 前者默认为true就行了. 这样我们可以让这个判定式保持consistent, 不必在一开始的时候单独判断dict.contains(s.substring(0, n))而不是dp[0] &amp;&amp; dict.contains(s.substring(0, n))这种形式.</p>
<h2 id="StringBuilder的toString"><a href="#StringBuilder的toString" class="headerlink" title="StringBuilder的toString()"></a>StringBuilder的toString()</h2><p>Returns a string representing the data in this sequence. A new String object is allocated and initialized to contain the character sequence currently represented by this object. This String is then returned. Subsequent changes to this sequence do not affect the contents of the String.<br>也就是toString()会生成一个新的string, 我们再对StringBuilder的改变不会影响这个新的string的content.</p>
<h2 id="Backtrack标记的原则"><a href="#Backtrack标记的原则" class="headerlink" title="Backtrack标记的原则"></a>Backtrack标记的原则</h2><p>Backtrack常用的就是标记, 或者给一个东西添加东西. 比如permutation, parentheses, 我们都要维护一个StringBuilder, 我们在某一个递归函数中给这个StringBuilder添加一个char然后进入下一个递归函数, 我们会担心返回来的时候的StringBuilder里面的内容还是我们刚添加完char的样子吗? 在向下调用的过程中会不会把这个StringBuilder给污染了. 我们可以这么想, 递归函数的功能包含了在接到是什么样子的StringBuilder那么在返回的时候还是什么样子. 比如permutation, 我们在某个level确定了某个位置是哪个字符, 此时的StringBuilder的状态假设为A, 然后继续向下, 等到又回来的时候, StringBuilder还是在A的状态. 我们秉承这个假设, 在对StringBuilder进行修改的时候, 认为递归函数是不会对StringBuilder进行改动的, 然后确保在递归函数返回之前把我们的修改撤销.<br>另一个例子就是word search那道题. </p>
<p>第18行我们对visited进行了修改, 中间19行到28行进行了递归函数的调用, 我们假设它们不会修改visited(其实是修改了但是返回的时候又把修改撤销了). 等我们到达29行的时候, visited只是进行了我们在18行的修改, 为了满足我们对递归函数的假设也就是返回前要把修改撤销, 我们在29行把18行的修改撤销即可.</p>
<h2 id="找到给定的intervals中-最多有多少个intervals互相会有交集"><a href="#找到给定的intervals中-最多有多少个intervals互相会有交集" class="headerlink" title="找到给定的intervals中, 最多有多少个intervals互相会有交集"></a>找到给定的intervals中, 最多有多少个intervals互相会有交集</h2><p>253题. 思路就是sort start和sort end得到两个arrays. 看最早结束的meeting前有多少个meeting会开始, 那么room数字就是多少, 等到有个meeting在最早结束meeting结束后开始, 那么这个最早结束的meeting占用的room就可以给这个新的meeting了, 此时room. 后续的meeting去看是否比第二早结束的meeting之前开始还是之后开始, 如果之前开始, 那么需要加room, 如果之后, 那么第二早结束的meeting所占用的room就可以给这个新的meeting了.</p>
<h2 id="String的大小是如何被比较的"><a href="#String的大小是如何被比较的" class="headerlink" title="String的大小是如何被比较的"></a>String的大小是如何被比较的</h2><p>逐位比较ASCII码的大小. 第0位相等就接着比较第1位, 以此类推, 直到比出大小. 如果一个string短, 一个string长, 比较到短的string的每位都和长的相等, 此时短的没东西和长的string比较了, 那么短的更小. 比如hello和hel, hel会排在hello前面. Hel和Hal比较, Hal在前面(更小).</p>
<h2 id="String类型的题的常用技巧"><a href="#String类型的题的常用技巧" class="headerlink" title="String类型的题的常用技巧"></a>String类型的题的常用技巧</h2><ol>
<li>Sliding window</li>
<li>DP</li>
</ol>
<h2 id="Sliding-Window-1"><a href="#Sliding-Window-1" class="headerlink" title="Sliding Window"></a>Sliding Window</h2><p>写sliding window的精髓在于两个pointer标记的地方是否属于window中, 我们的写法就统一都属于. 其次是包含新元素和pop走老元素的过程是如何体现的. 比如424题, include一个新元素的体现就是让count数组中对应位置的值 + 1. Pop走一个元素的体现就在于把count数组中对应位置的值 – 1. 这个include和pop的体现是sliding window的精髓, 而非是看此时的left或者right的位置. 只有完成了include我们才认为包含了right指向的元素, 只有pop走了, 我们才认为left可以移动到下一个位置, 在pop前, window一定包含left指向的元素. 在include前, 一定不包含right指向的元素.</p>
<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>DP是个很大的话题, 需要很多总结. 首先就是一些初始条件的确定. 比如416题, partition equal subset sum这道题. dp[0][0]是true. 也就是[0, 0]包含的元素中, 可以凑到0. 为什么这么规定? 假设有一个元素刚好等于我们的sum, 那么我们按照逻辑就会看前面的元素是否能凑到, sum – 该元素, 如果可以, 那么凑好的数字带上当前元素就能凑成sum. 于是我们让dp[m][0]是true即可(m &gt;&#x3D; 0).</p>
<p>写dp有时候不知道初始条件怎么写, 此时可以先试着写出状态转移方程. 写完后根据我们的要求去看如果遇到初始条件, 初始条件等于什么的时候满足我们的逻辑. 比如518, coin change 2. dp[i][j]表示前i + 1个元素凑j时有多少种凑法. 那么我们首先先想状态转移方程:<br>假设i和j都很大(这样可以让我们不用考虑出界等等一些边界条件, 这些等到后面再考虑), 那么dp[i][j] &#x3D; dp[i – 1][j] + dp[i][j – nums[i]], 也就是如果不带前i个元素最后一个元素时能凑成j的种类, 或者是带最后一个元素, 于是就是前i个元素凑成j – nums[i]的种类. 那么dp[0][0]是什么呢? 由于第0行没有i – 1行, 我们不妨直接看看前1个元素能凑成每个数字的种类最多肯定就是1. 假设第0个元素为3, 那么dp的第0行3的位置一定是1. 也就是前1个元素凑3最多只有一种方式. 那么看我们的转移方程, dp[0][3] &#x3D; dp[-1][3] + dp[0][0] &#x3D;&#x3D; 1, dp[-1]可以是假想的上一行, 那么自然而然上一行每一个位置都是0, 因为没有元素的话, 什么都凑不成. 于是dp[0][0]就自然而然是1了.</p>
<p>dp[0]不知道给什么值? 想一想什么情况下会取到dp[0]. 一般这种情况我们都知道答案, 不需要状态转移方程, 但是电脑需要状态转移方程计算. 那么接下来就是求未知数dp[0]了. 比如coin change. 如果目前是拿2凑2, 我们需要看凑0需要最少多少硬币, 再 + 1就是2凑2的个数. 我们知道拿2凑2只有一种, 那么凑0个最少硬币 + 1 &#x3D; 1, 于是凑0的最少硬币就是0, 因此dp[0] &#x3D; 0;</p>
<h2 id="给一堆数字凑数"><a href="#给一堆数字凑数" class="headerlink" title="给一堆数字凑数"></a>给一堆数字凑数</h2><p>感觉越写越乱. 一大类型就是给一堆数字去凑另一个数. 直接记住这个类型的不同情况, 本质就是凑0是可以凑到的.<br>1.	若是求用最少个数个数字去凑成target的, dp[i]表示的是凑成i需要最少的数字. 那么dp[0]就是0, 因为凑成0不需要任何数字, 直接就是0. (322题, coin change)<br>2.	若是求凑target有多少种凑法, dp[i][j]表示前i + 1个元素凑j一共的凑法, 那么dp[0][0]为1, 这表示前1个元素凑0有一种凑法, 那就是不给元素. (518题, coin change 2)<br>3.	若是求能否凑成target, dp[i][j]表示前i + 1个元素能否凑成j, 那么一样, dp[0][0]是true, 也就是前i + 1个元素可以凑成0. (416题)</p>
<h2 id="DP数组长度怎么定"><a href="#DP数组长度怎么定" class="headerlink" title="DP数组长度怎么定?"></a>DP数组长度怎么定?</h2><p>如果是string类型的就定为string.length() + 1.<br>如果是凑数类型的就定为target + 1.<br>如果还要牵扯到前多少个元素的, 就定为nums.length.</p>
<h2 id="DP的初始条件"><a href="#DP的初始条件" class="headerlink" title="DP的初始条件"></a>DP的初始条件</h2><p>dp的初始条件的确定比如dp[0], dp[1]是多少, 我们可以带入一些例子来看看我们把它们初始化多少符合我们的逻辑. 比如第96题, 我们把dp[0]初始化为1而不是0. 尽管0个nodes能组成0个BST也说得过去, 但是为了符合我们的逻辑(某个node作为root, 它左侧nodes组合BST个数乘上它右侧nodes组成的BST个数就是该node作为root能组成的BST的总个数), 我们需要让dp[0]等于1.</p>
<h2 id="关于compare的正反比较"><a href="#关于compare的正反比较" class="headerlink" title="关于compare的正反比较"></a>关于compare的正反比较</h2><p>return 里的东西如果小于0, one排在前面, 否则two排在前面, 于是上面的写法就是按lexicographical order排序. 如果这样写:</p>
<p>一样的return那个东西如果小于0, one在前, 否则two在前. 假设one的lexicographical order小于two, 那么return的是大于0, 于是two排前面, 于是这样排是倒序排.</p>
<p>通过给一些例子进去, 来看什么样的元素会被排在前面. 第一种是lexicographical order靠前的会被排在前面, 第二种则是倒序, 也就是lexicographical order大的靠前.</p>
<p>总结一下, 给的两个元素one和two. 如果就是return one – two或者one.field – two.field, 或者one.field.compareTo(two.field), 那么就是按照某个标准升序排列. 如果出现第二个参数在前的情况比如two – one或者two.field – one.field这样的, 那么就是按照某个标准倒序排列.</p>
<h2 id="关于缩2D-DP到1D-DP"><a href="#关于缩2D-DP到1D-DP" class="headerlink" title="关于缩2D DP到1D DP"></a>关于缩2D DP到1D DP</h2><p>模板就是dp长度和列数相同. 第0行的dp单独用一个循环来初始化. 然后之后每行更新dp的时候, 遇到边界要单独处理. 比如第64题. 开始时dp的长度是grid的列数. 然后第0行单独拎出来初始化dp. 之后每次到dp[0]的时候, 拎出来单独处理.</p>
<p>或者我们专门多新建一列一行来accommodate边界的情况. 见1143题. 由于我们需要用到右下对角的值, 因此需要用变量来存这个值.</p>
<h2 id="Palindrome题-从某个center扩张获得该center能到达的最长长度是多少或者该center有多少个palindromes"><a href="#Palindrome题-从某个center扩张获得该center能到达的最长长度是多少或者该center有多少个palindromes" class="headerlink" title="Palindrome题, 从某个center扩张获得该center能到达的最长长度是多少或者该center有多少个palindromes"></a>Palindrome题, 从某个center扩张获得该center能到达的最长长度是多少或者该center有多少个palindromes</h2><p>647题以及longest palindrome那道题. 模板一定要记好.</p>
<h2 id="Recursion到Recursion-memoization的过程"><a href="#Recursion到Recursion-memoization的过程" class="headerlink" title="Recursion到Recursion + memoization的过程"></a>Recursion到Recursion + memoization的过程</h2><p>首先想到recursion的解法, 然后发现有些情况是重复去做的, 于是想到用memoization. 用memoization时, 之前写好的递归函数不需要改, 唯一要加的就是传入一个memo数组或者map用来访问和存结果. 当我们想要的某个结果不在memo中时, 我们就去计算, 计算好后存到memo中.<br>因此recursion + memo的模板就是, 先看memo中有答案吗, 没有的话去计算, 计算好把答案存到memo中然后返回答案. 如果memo有答案, 那直接返回这个答案.</p>
<h2 id="Recursion-memoization到dp的过程"><a href="#Recursion-memoization到dp的过程" class="headerlink" title="Recursion + memoization到dp的过程"></a>Recursion + memoization到dp的过程</h2><p>一般来说helper function被传入不同的参数就代表dp中的不同状态. 我们观察helper function的signatrue来确定dp数组是一维的还是二维的. 比如1143这道题. 两个参数pos1和pos2标记着text1和text2要被截取的起始点, 也就是pos1和pos2标记着一种subproblem, 不同的subproblem拥有不同的(pos1, pos2)pair. 因此我们自然联想到dp用二维, dp[i][j]表示text1从i这个位置往后截取, text2从j这个位置往后截取, 这两个substring的LCS长度就是dp[i][j]. 因此观察helper function的signature. 接下来, 状态转移方程观察helper function的内容, 看当前传入的参数构成的subproblem是依赖哪些其他subproblem. 还是以1143这道题为例, 我们发现如果pos1和pos2指向的char相同, 那么就是取pos1 + 1和pos2 + 1构成的subproblem的答案 + 1; 如果不同, 那么就是取(pos1, pos2 + 1)和(pos1 + 1, pos2)构成的subproblem的最大的那个. 因此很自然得出:<br>如果pos1和pos2指向的char相同: <code>dp[pos1][pos2] = dp[pos1 + 1][pos2 + 1] + 1</code><br>否则: <code>dp[pos1][pos2] = Math.max(dp[pos1][pos2 + 1], dp[pos1 + 1][pos2])</code></p>
<h2 id="写循环的技巧"><a href="#写循环的技巧" class="headerlink" title="写循环的技巧"></a>写循环的技巧</h2><p>写循环首先就是要明确, 注意是明确重复干的事情是什么, 其次就是什么时候这个循环会停止. 就这两步. 比如763题. 我们从头开始, 看第0个字符的最右侧能达到多少, 和rightBound比较更新, 然后让pos + 1, 如果此时pos + 1后小于等于rightBound, 我们继续看此时pos指向字符的最右端能达到多少, 然后和rightBound比较更新. 于是我们就发现重复做的事情就是看当前位置的字符右侧最远能到达哪里, 然后更新rightBound. 什么时候停? 当pos超过rightBound的时候, 此时leftBound和rightBound之间的字符不会再在后面出现, 于是停止. 这个循环的过程我们也要循环做. 即此时pos指向的又是一个新的partition的开始. 那么外循环什么时候停止? 当pos &#x3D;&#x3D; s.length()的时候.</p>
<p>明确重复做的事情是什么, 明确循环停止的条件.</p>
<h2 id="获取一个int的每一个digit的方法"><a href="#获取一个int的每一个digit的方法" class="headerlink" title="获取一个int的每一个digit的方法"></a>获取一个int的每一个digit的方法</h2><h2 id="不用加减号计算a和b的sum"><a href="#不用加减号计算a和b的sum" class="headerlink" title="不用加减号计算a和b的sum"></a>不用加减号计算a和b的sum</h2><p>a ^ b是当前a和b二进制数字相加后得到的值(不带进位, 只是0 + 0得0, 0 + 1或1 + 0得1, 1 + 1得0).<br>a &amp; b是当前a和b二进制数字相加后得到的进位, 比如某一个位是1 + 1, 那么进位就是1. 由于这个进位要加在左边一位上, 因此需要(a &amp; b) &lt;&lt; 1.<br>当没有进位出现的时候, 这就是答案. 题目见371题</p>
<h2 id="给定的数组中duplicates-missing-number等等-并且数字的范围有限制"><a href="#给定的数组中duplicates-missing-number等等-并且数字的范围有限制" class="headerlink" title="给定的数组中duplicates, missing number等等, 并且数字的范围有限制"></a>给定的数组中duplicates, missing number等等, 并且数字的范围有限制</h2><p>Array index标记法.</p>
<h2 id="BST-level-traversal"><a href="#BST-level-traversal" class="headerlink" title="BST level traversal"></a>BST level traversal</h2><p>很多题都可以套用这个模板. 也就是遇到一个level, 首先看该level是否是第一次来(level &#x3D;&#x3D; levelList.size() ?).  102题.</p>
<h2 id="Monotonic-Deque-or-stack"><a href="#Monotonic-Deque-or-stack" class="headerlink" title="Monotonic Deque or stack"></a>Monotonic Deque or stack</h2><p>它的作用是给定一个数组, 我们能够知道任意位置比如i, 在i左边比nums[i]大的数字中index最大的那个是谁(previous greater), 同理也能知道i左边比nums[i]小的数字中index最大的那个是谁.</p>
<p>用排队来类比, 一个队从后面排, 如果你能打得过前面的人, 前面的人被踢出, 你能往前走一步, 一直到你打不过前面的人, 你就待在这里排队就行了.</p>
<p>类似地, 我们用一个deque, 存数组中数字的index. 从头(左边)开始遍历, 当我们来到index为i的位置时, 我们先看deque中比nums[i]小的数字都有谁, 有的就都出去, 直到deque是空的或者遇到比nums[i]大的数字了, 此时deque中last的那个index就是i左侧比nums[i]大的数字中index最大的那个index. 之后把i压进deque中走下一个位置.<br>这是decreasing deque(从左往右看是decreasing).</p>
<p>如果是构建increasing deque, 那么就是比nums[i]大的数字出去, 直到deque空或者有比nums[i]小的数字出现, 之后把i压进去即可.</p>
<p>为什么往deque中压index而不是index对应的数字? 因为我们可以通过index获取对应的数字, 同时我们也能知道这个数字在数组中的什么位置, 一举两得.</p>
<p>以上是Sliding window max收获.<br>至于是构建deque还是stack, 我们根据需要, 像是sliding window max, 我们需要每次都知道比某个数字大的的数字中index最大是多少并且也要及时清理window之外比该数字大的index对应的数字, 也就是两头都要操作. 那么用deque, 像是581, 我们不需要知道最大值或者最小值, 那么用stack也就够了.</p>
<p>一句话就是monotonic stack是为previous greater, next greater, previous smaller和next smaller问题而生的. Trapper rain water也是类似的. 我们到达一个地方后, 知道左侧max是多少, 但是不知道next greater有没有, 于是想到了monotonic stack.</p>
<h2 id="关于monotonic-stack最新的感想-这个结论十分重要"><a href="#关于monotonic-stack最新的感想-这个结论十分重要" class="headerlink" title="关于monotonic stack最新的感想(这个结论十分重要)"></a>关于monotonic stack最新的感想(这个结论十分重要)</h2><p>我在床上睡醒想这个monotonic stack, 总感觉少理解点儿了啥, 这是因为我做了862这道题, 有些不解它的逻辑. 然后一直在想我对monotonic stack&#x2F;queue的理解哪里出现了疏漏, 之后我得出了一个结论, 这个结论不知道对不对, 但我感觉应该是对的, 如果是对的, 那就理解了mono stack了. 现在我来说明. 以increasing stack为例, 我们在某个位置时, 我们按照规则是先把stack中比自己大的都pop出去, 如果pop到最后stack还有元素, 那么栈顶的这个数字就是在我们左侧, 距离自己最近的并且比自己小的数字的index. 意思就是对于index是i, i &lt; pos(pos是我们现在的位置), 那些满足nums[i]小于nums[pos]的值中, 最大的那个就是栈顶的值. 问题就是此时stack装的index可能不止一个, 除了栈顶的, 下面被压的index是什么? 我们以栈顶为开始, 标记为0, 此时的值假设表示为stack[0]&#x2F;(当然stack不能用index访问), 这里只是方便表达, 我们研究的数组假设为nums, 此时我们所在的位置是i. 那么stack[1]就表示栈顶下面这个数字. 我们就有nums[stack[1]] &lt; nums[stack[0]]并且stack[1]是比nums[stack[0]]的previous smaller的index. 那么如果stack[1]下面还有元素, 那么stack[2]就是nums[stack[1]]的previous smaller的index, 如果stack[2]下面还有元素, 那么stack[3]就是nums[stack[2]]的previous smaller的index. 以此类推, 直到我们到达栈底, 假设这个位置是n, 那么nums[stack[n]]没有previous smaller.<br>感觉有些难以理解, 我们举个例子吧.<br>注意stack里压的是index, 我们维持的是increasing stack.<br>nums &#x3D; [3, 5, 7, 35, 24, 27, 16, 29, 1, 4, 7]<br>stack一开始为空.</p>
<p>当i &#x3D; 0:<br>stack是空的, 也就是到达了栈底, 那就说明没有比nums[0]小的数, 这也对应nums[0]确实没有previous smaller. 目前均满足我们的结论.<br>push 0进栈.<br>stack[0]</p>
<p>当i &#x3D; 1:<br>此时nums[i] &gt; nums[stack.peek()]于是不pop. 那么nums[i]的previous smaller的index就是栈顶的值也就是0. nums[0]的previous smaller没有, 因为0在栈底, stack中0之前没东西了, 这也对应nums[0]确实没有previous smaller. 目前均满足我们的结论.<br>push 1进栈.<br>stack[0, 1]</p>
<p>当i &#x3D; 2:<br>此时nums[i] &gt; nums[stack.peek()]于是不pop. 那么nums[i]的previous smaller的index就是1. nums[1]的previous smaller我们之前得出是0, 这也对应stack中1下面的0. 然后对于0, 因为stack中0之前没东西了(处于栈底), 所以nums[0]的previous smaller没东西, 也对应nums[0]确实没有previous smaller. 目前均满足我们的结论.<br>push 2进栈.<br>stack[0, 1, 2]</p>
<p>当i &#x3D; 3:<br>此时nums[i] &gt; nums[stack.peek()]于是不pop. 那么nums[i]的previous smaller的index就是2. 然后nums[2]的previous smaller是1也对应stack中2下面的那个1. nums[1]的previous smaller是0也对应stack中1下面的0, nums[0]没有previous smaller刚好也对应stack中0下面没东西(处于栈底). 目前均满足我们的结论.<br>push 3进栈.<br>stack: [0, 1, 2, 3]</p>
<p>当i &#x3D; 4:<br>此时就有意思了, 栈顶是3, 此时nums[i] &lt; nums[3]. 我们要把3给pop出去. 然后再看, 发现nums[i]比nums[2]大, 于是不再pop. 此时nums[i]的previous smaller就是nums[2]也就是nums[stack.peek()], nums[i]的previous smaller的index是2. 然后看栈顶的2对应的nums[2]的previous smaller是nums[1](这是我们之前得到的结论), 这也对应stack中2下面的是1. 然后看nums[1]的previous smaller是nums[0](这也是我们之前得到的结论), 也完美对应stack中1下面那个0. nums[0]没有previous smaller, 也对应0处于栈底. 目前均满足我们的结论.<br>push 4进栈.<br>stack: [0, 1, 2, 4]</p>
<p>当i &#x3D; 5:<br>nums[i] &gt; nums[stack.peek()], 此时nums[i]的previous smaller就是nums[stack.peek()], 也就是4是nums[i]的previous smaller的index. 然后看栈顶的4, nums[4]的previous smaller就是nums[2](我们之前得到的结论), 这刚好对应stack中4下面的那个2. 然后nums[2]的previous smaller是nums[1]刚好对应stack 2下面的1. nums[1]的previous smaller是nums[0], 刚好对应stack中1下面的那个0, nums[0]的previous smaller没有, 刚好对应0在栈底. 以此类推.<br>….</p>
<p>我们都能以这样的逻辑去走下去, 发现每一次都满足我们之前下的结论.</p>
<p>总结一下就是,<br>我们到某个位置i时, 我们想知道nums[i]的previous smaller是谁呢? 于是我们把stack中比nums[i]大的pop出去, 此时剩下的那个栈顶的值stack.peek()就是nums[i] previous smaller的index. 假设stack.peek()是j. j就是nums[i]previous smaller的index. 那nums[j]的previous smaller的index是谁呢? 如果stack中j下面还有东西, 那么nums[j]的previous smaller就是nums[栈中j下面的值], 假设stack中j下面的数字是z. 那么nums[z]就是nums[j]的previous smaller, z就是nums[j]就是previous smaller的index. 那nums[z]的previous smaller是谁呢? 假如stack中z下面还有数字假设是x, 那么nums[x]就是nums[z]的previous smaller. x是nums[z]的previous smaller的index. 那么nums[x]的previous smaller呢?… 我们还可以按照同样的逻辑去找. 直至我们遇到栈底. 假设栈底的值是m, 那么此时nums[m]没有previous smaller.</p>
<p>希望这个结论是对的.</p>
<h2 id="精简代码背后蕴藏着复杂的思考"><a href="#精简代码背后蕴藏着复杂的思考" class="headerlink" title="精简代码背后蕴藏着复杂的思考"></a>精简代码背后蕴藏着复杂的思考</h2><p>有时候精简的代码蕴含着复杂的思考迭代过程. 比如581最后一种解法, 为什么有的元素sort后的位置就是最后一次pop出来的index, 而有的不是. 有些写法是考虑到所有情况后总结出来的能cover所有情况的精简写法, 是复杂思考过程的高度简化. 因此我们一开始看不懂是太正常不过了, 我们从简单一点点复杂深入思考, 分类讨论, 来理解这些写法.<br>首先要记得我们要找的是最靠左的leftBound和最靠右的rightBound.<br>一开始如果一直是递增或者出现平台, 那么从0开始的每一个index都会被压进栈里面, 如果一直是这样, 那么说明array已经sorted了, 此时<br>返回0即可. 如果遇到到某个位置出现递减, 那么就要看左侧比它小的元素的对应的index都有谁, 于是我们开始pop, 当pop到某个位置,<br>发现栈顶的index对应的element比自己小, 那么这个index + 1就是我们sort后应该在的位置. 但是注意刚才我们pop的时候,<br>每一个从0开始的index都按顺序被push进栈, 因此每一个index都是互相相邻的,<br>于是我们最后一次pop的那个index比当前栈顶的index大1, 因此就是sort后我们应该待的位置.<br>记录下这个leftBound. 然后我们把自己的index压入栈中. 如果之后的数字始终没有把我们pop出来或者刚好把我们pop出来,<br>我们之前的index都没出栈,那么leftBound往左最远到达的, 就是我们第一次记录的那个leftBound.<br>如果出现不仅把我们pop出去也pop出了一个或多个我们之前的index, 那么一样的道理, 之前的index都是相邻的,<br>最后一次pop出来的值比栈顶的index大1, 那个值应该在的index. 当然也可能pop到栈里没东西了, 但这种情况也满足sort后在的位置<br>应该是最后一次pop的index.<br>这是当时581那道题的思考, 为什么可以写成l &#x3D; Math.min(l, stack.pop()), 难道不应该是pop不动时栈顶的index + 1才是该元素sort后应该待的位置吗? 这个解释就解决了我们的疑惑.</p>
<h2 id="需要知道多少元素满足条件-哪些没有满足条件"><a href="#需要知道多少元素满足条件-哪些没有满足条件" class="headerlink" title="需要知道多少元素满足条件, 哪些没有满足条件"></a>需要知道多少元素满足条件, 哪些没有满足条件</h2><p>395题, 我们需要知道window中的char的count是否都超过K, 只有这样, 此时的window包含的substring才是满足题意的. 我之前使用Set来存哪些char的count没有超过K, 然后每次看set是否为空来判断window中的char的count是否都超过K. 更聪明的做法就是用一个变量记录window中count超过K的cha的个数, 因为我们不需要知道具体是哪些char的count超过了K, 只需要知道数量就行, 当这个数量和window中的unique chars的个数相同时, 我们就知道所有的char的count都超过了K. 这个思路很常用. 当我们不需要知道特定哪些元素满足某个条件但是又想知道是不是在某个范围内所有的元素都满足条件的时候, 我们就用变量记录满足条件的元素的个数, 然后当满足条件的元素的个数和范围内元素的个数相同时, 说明此时所有的元素都满足了条件.</p>
<h2 id="ArrayList的constructor可以直接扔进去个set"><a href="#ArrayList的constructor可以直接扔进去个set" class="headerlink" title="ArrayList的constructor可以直接扔进去个set"></a>ArrayList的constructor可以直接扔进去个set</h2><p>实际上只要是collection就行. 具体见官方文档.</p>
<h2 id="BFS打标签"><a href="#BFS打标签" class="headerlink" title="BFS打标签"></a>BFS打标签</h2><p>其实是在level order traversal中比较好用的一个点. BFS无非就是pop出该level的所有的node, 把下一个level的node添加进来. 我们用一个变量记录我们当前的level是多少. 在开始该level的BFS前(该level的BFS就是把该level的node从queue中pop出来, 再把下一个level的node添加进来的过程), 变量记录的值表示现在queue中node属于哪个level, 在我们BFS过后, 我们让变量 + 1. 此时变量记录的值表示现在的queue中node属于哪个level. 切记这两个判定点, 一个是BFS前, 一个是BFS结束更新完level变量.</p>
<!-- ## Sliding window maximum和min stack那道题有非常大的联系
因为min stack我当时想的是某个时刻知道了min, 但如果这个min被pop出去了, 那比次min是哪个呢? 次min出去了那次次min是哪个呢? 于是我们用了一个额外的stack来存某个时刻的min, 如果某个时刻比上一时刻的min小, 那么此时的min就是这个元素, 这样即使此时的min被pop出去, 次min还在stack中好好待着呢. Sliding window maximum也是, 我们从左到右遍历, 就能知道到达某个位置时, 从这里以及到左侧的最大值是多少. 但是问题就是如果这个最大值不在我们的window里面怎么办, 我们就需要知道次最大值, 然后看它是否在window中, 以此类推, 直到遇到一个数在我们的window里面且比我们大, 或者在我们window里面的就没有比我们大的, 那么此时我们自己就是window中最大的. -->

<h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><p>这个是在给定一个array, 想知道每个元素出现的频率从大到小排是什么样的时候, bucket sort就起作用了. 先统计每个元素的频率, 并得到<br>出现最多次数的频率是多少, 之后再分配一个长度为最多频率 + 1长度的list, 每个位置放一个list来存对应的元素. 元素根据自己的频率到这个<br>list中相应index的bucket, 也就是这个list中装了许多list(bucket), 元素的频率就对应着应该在这个list中哪个index的bucket.<br>然后反着遍历即可按照频率从大到小找到元素.</p>
<h2 id="log1-log2-log3…-logn也就是log-n-是多少"><a href="#log1-log2-log3…-logn也就是log-n-是多少" class="headerlink" title="log1 + log2 + log3… + logn也就是log(n!)是多少"></a>log1 + log2 + log3… + logn也就是log(n!)是多少</h2><p>O(log(n!)) &#x3D; O(nlogn)<br>下面这个网页是证明过程.<br><a target="_blank" rel="noopener" href="https://math.stackexchange.com/questions/482860/how-to-calc-log1-log2-log3-log4-log-n">https://math.stackexchange.com/questions/482860/how-to-calc-log1-log2-log3-log4-log-n</a></p>
<h2 id="Prefix-sum"><a href="#Prefix-sum" class="headerlink" title="Prefix sum"></a>Prefix sum</h2><p>对于那种prefix sum凑数的题, 首先看自己是否能凑到, 再看我是不是要减去前面某个prefix sum来凑到target. 这个先看自己再看别人的思路很重要.</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>记得如何使用BigDecimal</p>
<h2 id="Cyclic-sort"><a href="#Cyclic-sort" class="headerlink" title="Cyclic sort"></a>Cyclic sort</h2><p>把数字放到它应该在的位置. 比如给定一个nums. 假设长度为n, 那么在1到n的范围内的数字, 1的位置是index 0, 二的位置是index 1, 三的位置是index 2…以此类推. 我们从左开始遍历, nums[0]如果不在应该在的位置, 那么把它放到它应该在的比如x这个位置, 那么nums[x]的值就被交换到了0这个位置, 可能nums[x]也不应该在0这个位置, 于是继续放. 直到我们交换来一个nums[m], nums[m]应该去的位置发现就是nums[m], 这就说明我们把尽可能多的数字放到了它们该去的位置, 再继续下去没有意义了, 因为就是相同数字开始反复互相交换. 于是我们到nums[1]开始继续这个过程. 前提就是nums中的数字必须是在1到n的范围内. 像是41题找first missing positive. 有些数字可能出界, 那么这些数字我们就不考虑. 到最后遍历完数组后, 在范围内的数字就能在它们该在的位置, 我们再从头遍历, 看哪个数字没有在该在的位置, 这就说明这个位置该有的数字missing了, 于是就返回它即可.</p>
<p>这应该也是给定nums, 长度为n, 假设nums中的数字就是1到n, 想出O(n) sort的方法.</p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>顺时针转: 先转置, 再左右reverse.<br>逆时针转: 先转置, 再上下reverse.</p>
<h2 id="Sliding-Window其实就是剪枝"><a href="#Sliding-Window其实就是剪枝" class="headerlink" title="Sliding Window其实就是剪枝"></a>Sliding Window其实就是剪枝</h2><p>突然感觉sliding window就是把brute force所有substring都试一遍的升级版, 也就是有些substring我们通过逻辑判断就知道不可能是答案, 因此直接排除, 没必要再看. </p>
<p>比如当right达到某个位置不满足题意的时候，以现在的left为start，以right现在的位置以及右侧的位置为end来界定的substrings都不会满足题意或者不会是答案，于是我们没必要遍历，提前剪枝, 直接让left右移，发现sliding window框起来的还不满足题意，那一样的以当前left为start的所有substring都不满足题意或者说都不够好来成为答案，可以直接继续移动left。<br>sliding window是capture了一个substring。我们根据一些判断逻辑只研究有可能是答案的substring并且不研究哪些被逻辑排除掉的substring。 </p>
<p>比如424题, 我们初始化left为0, right为0, 然后让right开始走. 当走到一个位置发现sliding window里的除了拥有最大frequency的其他char的数目大于k的时候, 此时以left为start的substring最长满足题意的就是[left, right)框起来这个区间, 左闭右开. 为什么? 如果right继续移动, 假设之后window里的freq最大的char没有改变, 那不用说, 本来剩下的char的数目就大于K, 往后只可能剩下的越来越多, 最好情况也就是剩下的数目不变, freq最大的char的个数一直在增加, 因此不满足题意; 如果后面在某个时刻freq最大的char改变了, 此时我们来证明一下. 首先我们假设在之前right停止的位置, 最大freq char假设是‘a’, 个数为x个, 下一次将成为max freq char现在的count是y, 其余剩余的char个数为z个, 此时总个数为x + y + z个, 我们把总数记为S1. 此时有S1 - x &gt; k. 那么到了某个时刻, 最大freq char换成比如说‘b’了, 假设‘a’增加了m1个, 此时count是x + m1, ‘b’增加了m2个变为了, 此时count是y + m2, 其余的char的总增量是m3, 因此现在就是z + m3. 我们要判断的就是x + z + m1 + m3是否大于k. 我们知道此时的y + m2 &gt; x + m1. 于是我们有:<br>S1 + m1 + m2 + m3 – (y + m2) &gt; S1 + m1 + m2 + m3 – (x + m1)的<br>不等式右边又有:<br>S1 + m1 + m2 + m3 – (x + m1) &#x3D;&#x3D; S1 -x + m2 + m3<br>我们知道S1 – x大于k并且m2 + m3是大于等于0的, 因此不等式右边是大于k的. 由于左侧大于右侧, 那么左侧也是大于k的, 而左侧正是此刻除了b以外, 其他char的total count. 至此, 我们证明完毕.</p>
<p>所以sliding window能成的重要原因就是可以通过逻辑排除.</p>
<p>到这里, right不满足题意, 以left作为start, 以right及其它之后的位置作为end的所有substring都不行, 于是我们记录此时的left和right界定的长度 – 1, 因为不包括right. 然后移动left一格. 此时如果pop走的不是max freq, 此时window里的非max freq char就满足题意了, 我们可以继续走, 至于为什么移动一步left就满足, 见我之前写的注解. 简单来说就是来到right前一定满足非max freq小于大于等于k. 来到了right发现大于k了, 说明引入了非max freq char, 我们左侧如果移走一个, 那window就valid了. 如果pop走的是max freq对应的char, 那么我们就要看pop完后的maxFreq是谁, 再看剩下的其他char的count是否满足题意, 如果是那right可以继续走了, 如果不是那继续移动left. 我们是在right走不动的时候计算maxLength.</p>
<p>网友给的答案很巧妙. 当right走不动的时候, 说明right上一步在的地方框起来的window还满足题意, 现在不行了. 于是我们会计算此时的substring length就是right – left因为我们不包含right. 但是网友不这么干, 它此时先让left右移一位, 此时right – left + 1和之前的right – left一个长度. Left向右移动一位后, 我们记录此时的大小并且和maxLength比较. 目前为止, 不管是移动left前right – left还是移动left后的right – left + 1. 得到的值都是一样. 然后这里就面临了一个问题, 刚才pop出去的是max freq对应的char吗? 如果不是, 那么此时的window已经valid了, right可以继续走; 如果是, 那么此时的window可能是valid, 也可能不是, 常规操作就是去缩left, 然后等到window valid之后再去移动right. 但其实不用缩. 因为我们是求最长的, 那么此时我们的window扩展到了这个地步, 我们就按照这个window size走, 如果后面还能扩, 我们继续更新maxLength, 如果不行我们就维持这个size一直到结束. 不缩window size是这道题的关键.</p>
<h2 id="Quick-sort和quick-select的口诀"><a href="#Quick-sort和quick-select的口诀" class="headerlink" title="Quick sort和quick select的口诀"></a>Quick sort和quick select的口诀</h2><p>升序, 大小小大, 对应第一个if的两个判断条件和后面两个if的判断条件.<br>降序, 小大大小, 同样是对应那四个条件.</p>
<h2 id="如果想不出答案-想一想答案的特征是什么"><a href="#如果想不出答案-想一想答案的特征是什么" class="headerlink" title="如果想不出答案, 想一想答案的特征是什么"></a>如果想不出答案, 想一想答案的特征是什么</h2><p>寻找最后答案的特征 然后遍历所有拥有这个特征的情况 从中找出我们的答案. 比如histogram那道题 答案的特征就是总会有一个bar作为minimum，遍历所有bar做minimum的情况，计算每个bar做minimum时的largest rectangle，最后得出全局最大.</p>
<h2 id="求两个数字谁距离某个数字近"><a href="#求两个数字谁距离某个数字近" class="headerlink" title="求两个数字谁距离某个数字近"></a>求两个数字谁距离某个数字近</h2><p>比如给定两个数字x, y并且x &lt; y. 再给我们的数字n, 求谁距离n近.<br>比较n - x和y - n的大小即可. 此时必须满足x小于y, 如果x大于y, 那么用这个不等式判断得出的结果是不对的. 毕竟如果x特别大, y等于n等于1, 不等式左边则是很小的数字, 而不等式右侧为0, 此时我们会认为x距离n更近其实不是. 这个结论的启发来自于658题.</p>
<h2 id="Binary-Search搜索平方数的用法"><a href="#Binary-Search搜索平方数的用法" class="headerlink" title="Binary Search搜索平方数的用法"></a>Binary Search搜索平方数的用法</h2><p>就是比较mid的平方和target(因为这里我们搜索的范围是1到某个值, 中间是连续的, 而不是去在某个数组里面搜索, 因此我们直接用mid). 问题就是mid的平方可能会出界. 于是我们想到使用mid和target &#x2F; mid比较. 如果mid &lt; target &#x2F; mid. Target &#x2F; mid可能会带小数, 然后舍弃掉, 即使这样也比mid大, 那说明mid太小的, 应该让right  &#x3D; mid + 1. 如果mid &gt; target &#x2F; mid. Target &#x2F; mid可能带小数舍弃掉, 舍弃掉后, mid比target &#x2F; mid大, 那说明二者整数部分mid就比target &#x2F; mid大, 即使target &#x2F; mid带上小数部分, mid也是更大的, 因此此时让left &#x3D; mid – 1. 如果mid &#x3D;&#x3D; target &#x2F; mid, 我们要分两种情况, 一种是target &#x2F; mid没有小数部分, 刚好整除, 那么此时mid就是target的平方根; 如果target &#x2F; mid带小数, 那么说明这个mid是小, 从而让target &#x2F; mid拥有了小数部分, 因为mid和target &#x2F; mid就是此消彼长. 因此我们要让right &#x3D; mid + 1, 但其实此时已经可以判断target的平方根不是整数了. 因为mid + 1的平方肯定大于target. 因为现在是mid * (mid + target &#x2F; mid的小数部分)刚好等于target, 那么mid + 1乘上mid + 1则是让两个乘数都变大了, 那结果一定大于target. </p>
<p>总结就是, 如果mid &lt; target &#x2F; mid或者mid &gt; target &#x2F; mid不需要考虑小数舍弃这种, 就按实际生活里的计算对待, 此时就是mid比较小或者mid比较大. 等到mid &#x3D;&#x3D; target &#x2F; mid时, 再去考虑小数的舍弃问题.</p>
<h2 id="什么时候想到用prefix-sum"><a href="#什么时候想到用prefix-sum" class="headerlink" title="什么时候想到用prefix sum"></a>什么时候想到用prefix sum</h2><p>Subarray凑数的时候. 或者说看到有subarray出现的时候.</p>
<h2 id="brute-force优化"><a href="#brute-force优化" class="headerlink" title="brute force优化"></a>brute force优化</h2><p>从brute force进行优化其实用的就是我们是否能用逻辑排除一些情况, 从而不需要让程序去走这些情况节省时间. 只让程序去走可能的情况, 从而告诉我们这些可能的情况中我们想要的答案. 重点就在于逻辑推理. 可以看84, 632以及424题我的逻辑推理, 如何排除一些不可能的情况.</p>
<!-- 1048, 1654, 696, 134
给两个lis‍‌‍‌‍‌‌‍‍‍‍‌‌‍‌‌‌‍‍‍t of string，输出各对应string需要改变几个字符能变成anagram
secret array(counting analogous array)
输入：2d prefix sum 的matrix. 输出：2d matrix 原来的样子。 ----Hint: (Value[i][j] = Sum[i][j] - Sum[i-1][j] - Sum[i][j-1] + Sum[i-1][j-1] --></div><div class="tags"><a href="/tags/tricks"><i class="fa fa-tag">tricks</i></a></div><div class="post-nav"><a class="pre" href="/2022/08/18/21-Merge-Two-Sorted-Lists/">21. Merge Two Sorted Lists</a><a class="next" href="/2022/08/16/20-Valid-Parentheses-Easy/">20. Valid Parentheses - Easy</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img src="/img/dark_side_of_the_moon.jpeg"/></a><p>Calm Patient Persistent</p><a class="info-icon" href="mailto:tongxinn@andrew.cmu.edu" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/FelderMountain" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://www.linkedin.com/in/tongxin-niu" title="LinkedIn" target="_blank" style="margin-inline:5px"> <i class="fa fa-linkedin-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Always-Review-Here/">Always Review Here</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode-Notes/">LeetCode Notes</a><span class="category-list-count">110</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Templates/">Templates</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://leetcode.com/Pinkman_Ox/" title="Pinkman LeetCode" target="_blank">Pinkman LeetCode</a><ul></ul><a href="https://www.youtube.com/watch?v=PLIAp5nr0q0" title="Live Aid (Queen) [1985, London, Wembly Stadium]" target="_blank">Live Aid (Queen) [1985, London, Wembly Stadium]</a><ul></ul><a href="https://www.bilibili.com/video/BV15f4y1p7Gq?spm_id_from=333.337.search-card.all.click&amp;vd_source=36313f6ca20b47d3b8d1740651933b35" title="Hotel California (Eagles) [1994, Hell Freezes Over]" target="_blank">Hotel California (Eagles) [1994, Hell Freezes Over]</a><ul></ul><a href="https://www.youtube.com/watch?v=FcoUvu0mGog" title="Fade to Black (Metallica) [2018, Lincoln, NE]" target="_blank">Fade to Black (Metallica) [2018, Lincoln, NE]</a><ul></ul><a href="https://www.youtube.com/watch?v=Ly6ZhQVnVow" title="Stairway To Heaven (Led Zeppelin) [1975, Live at Earls Court]" target="_blank">Stairway To Heaven (Led Zeppelin) [1975, Live at Earls Court]</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">Pinkman Tech Space.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>